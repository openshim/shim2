# 実機計測

  - [はじめに](#はじめに)
    - [実行環境](#実行環境)
  - [実行のための準備](#実行のための準備)
    - [準備](#準備)
    - [実行サイクル取得用のマクロを挿入する](#実行サイクル取得用のマクロを挿入する)
      - [**run.sh**を動かす](#runshを動かす)
      - [*insertMacro/c_src* 内に *c_src_Macro* というディレクトリができているのを確認する](#insertmacroc_src-内に-c_src_macro-というディレクトリができているのを確認する)
    - [*c_src_Macro* 内のプログラムをクロスコンパイルする](#c_src_macro-内のプログラムをクロスコンパイルする)
  - [実機で実行し、実行サイクルを取得する](#実機で実行し実行サイクルを取得する)
    - [注意点](#注意点)
      - [PMUの起動](#pmuの起動)
      - [動作周波数の固定](#動作周波数の固定)
      - [結果の出力方法](#結果の出力方法)
        - [各カラムの説明](#各カラムの説明)

## はじめに

本ディレクトリでは計測プログラムを実機用にクロスコンパイルし、実行サイクルを取得する機能を提供します。
具体的には以下の通りです。

+ [実行サイクル取得用のマクロを挿入する](#実行サイクル取得用のマクロを挿入する)
+ [実機で実行するためにクロスコンパイル](#c_src_macro-内のプログラムをクロスコンパイルする)
+ [実機で実行し、実行サイクルを取得する](#実機で実行し実行サイクルを取得する)

### 実行環境

以下のプラットフォームでの実行を確認しています。

+ 環境
  + *Ubuntu ver.16.04LTS*
<br>

+ ターゲットハードウェア
  + *Raspberry Pi3 Model B+*
    + *CPU*：*Cortex-A53*
    + *OS*：*Linux ver4.14.68*

## 実行のための準備

実行のために計測プログラムにマクロを挿入する流れを説明します。

### 準備

実行するには以下のツールが必要です。

+ *Python* の実行環境
  + *ver 2.7.12* での実行を確認
+ ターゲットのハードウェア向けにクロスコンパイルする環境
  + 製作者はコンパイラに *aarch64-poky-linux* を使用


準備するファイルは以下の通りです。

+ [*c_src*](../c_src/)の計測プログラム
    + *c_src* ごと *insertMacro* 内に配置する

### 実行サイクル取得用のマクロを挿入する

挿入する手順は以下の通りです。

  1. [**run.sh**を動かす](#runshを動かす)
  2. [*insertMacro/c_src* 内に *c_src_Macro* というディレクトリができているのを確認する](#insertmacroc_src-内に-c_src_macro-というディレクトリができているのを確認する)

#### **run.sh**を動かす

動かし方は以下の通りです。

`sudo ./run.sh c_src/*`

#### *insertMacro/c_src* 内に *c_src_Macro* というディレクトリができているのを確認する

*c_src* 内に *c_src_Macro* ができていて、そのディレクトリの中にマクロが挿入された計測プログラムがあるのを確認してください。

### *c_src_Macro* 内のプログラムをクロスコンパイルする

ターゲットのハードウェアで実行できるようにクロスコンパイルしてください。

## 実機で実行し、実行サイクルを取得する

コンパイルした実行ファイルをUSBメモリ等でターゲットハードウェアに移し、実行してください。

### 注意点
以下の3点に注意して実行してください。

1. [*PMU* の起動](#pmuの起動)
2. [動作周波数の固定](#動作周波数の固定)
3. [結果の出力方法](#結果の出力方法)

#### PMUの起動

[*PMU_module*](PMU_module) 内の3種類のカーネルモジュール(***.ko*)を以下のコマンドでロードしてください。

`insmod (カーネルモジュール)`

#### 動作周波数の固定

[*PMU_module*](PMU_module) 内の**cpusetup.sh**を以下のコマンドで動かしてください。

`./cpusetup3.sh`

#### 結果の出力方法

実行結果は、以下の例のようにcsvファイルに出力してください。
(*BubbleSort* は**BubbleSort.c**をコンパイルしたファイル)

`./BubbleSort > res_BubbleSort.csv`

csvファイルには以下のような結果が出力されていることを確認してください。

```bash
L1I-Refill,,,,L1D-Refil,,,,L1D-Access,,,,L1I-Access,,,,L2D-Access,,,,L2D-Refill,,,,
Total,Start,End,lap,Total,Start,End,lap,Total,Start,End,lap,Total,Start,End,lap,Total,Start,End,lap,Total,Start,End,lap,
775,7131,7906,775,163,5122,5285,163,74496,3968026,4042522,74496,92733,9955366,10048099,92733,1101,22235,23336,1101,237,2071,2308,237,
1403,6366,6994,628,251,4948,5036,88,147372,3646561,3719437,72876,181942,9158109,9247318,89209,1910,20774,21583,809,601,1719,2083,364,
.
.
.
35050,6353,7044,691,6781,4417,4543,126,7072631,1807635,1881169,73534,8500710,4620092,4710709,90617,50606,19746,20707,961,18628,1888,2255,367,
35816,6667,7433,766,6917,4294,4430,136,7146198,1811331,1884898,73567,8590754,4627120,4717164,90044,51650,20123,21167,1044,18965,1853,2190,337,
-----------------------
TotalTime,22501440,Iteration,100
exec count,225014
L1access,71261
L1missrate,0.000943
L2missrate,0.367183
```
<br>

##### 各カラムの説明

それぞれ *Iteration* 回、*L1I/L1D/L2D* について *Refill* 回数と *Access* 回数を取得しています。
*PMU* を用いて上記のイベントの回数を取得しています。*Total、Start、End、lap* は以下のように表されます。

|カラムの名前|説明|
|---|---|
|Start|計測プログラムを始めるときのイベントカウンタの数|
|End|計測プログラムが終わるときのイベントカウンタの数|
|lap|*lap = End - Start*|
|Total|*Total = lap*の総和|

最後に出力されるパラメータは下記の通りです。

|パラメータ名|パラメータの説明|
|---|---|
|TotalTime|*Iteration*回実行した実行サイクルの和|
|Iteration|マクロで定義したプログラムを実行する回数|
|exec count|実行サイクルの平均回数 (*TotalTime / Iteration*)|
|L1access|L1アクセス回数の平均回数|
|L1missrate|L1キャッシュミス率 (*L1-Rifill / L1-Access*)|
|L2missrate|L2キャッシュミス率 (*L2-Refill / L2-Access*)|

注）この計測手法ではPMU取得値の関係でキャッシュミス率を(Refill / Access)で見積もっています。